{
  "name": "jake",
  "description": "JavaScript build tool, similar to Make or Rake",
  "keywords": [
    "build",
    "cli",
    "make",
    "rake"
  ],
  "version": "0.7.7",
  "author": {
    "name": "Matthew Eernisse",
    "email": "mde@fleegix.org",
    "url": "http://fleegix.org"
  },
  "bin": {
    "jake": "./bin/cli.js"
  },
  "main": "./lib/jake.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/mde/jake.git"
  },
  "preferGlobal": true,
  "dependencies": {
    "minimatch": "0.2.x",
    "utilities": "0.0.x"
  },
  "devDependencies": {
    "q": "0.9.x"
  },
  "engines": {
    "node": "*"
  },
  "readme": "### Jake -- JavaScript build tool for Node.js\n\n[![Build Status](https://travis-ci.org/mde/jake.png?branch=master)](https://travis-ci.org/mde/jake)\n\n### Installing with [NPM](http://npmjs.org/)\n\nInstall globally with:\n\n    npm install -g jake\n\nOr you may also install it as a development dependency in a package.json file:\n\n    // package.json\n    \"devDependencies\": {\n      \"jake\": \"latest\"\n    }\n\nThen install it with `npm install`\n\nNote Jake is intended to be mostly a command-line tool, but lately there have been\nchanges to it so it can be either embedded, or run from inside your project.\n\n### Installing from source\n\nPrerequisites: Jake requires [Node.js](<http://nodejs.org/>), and the\n[utilities](https://npmjs.org/package/utilities) and\n[minimatch](https://npmjs.org/package/minimatch) modules.\n\nGet Jake:\n\n    git clone git://github.com/mde/jake.git\n\nBuild Jake:\n\n    cd jake && make && sudo make install\n\nEven if you're installing Jake from source, you'll still need NPM for installing\nthe few modules Jake depends on. `make install` will do this automatically for\nyou.\n\nBy default Jake is installed in \"/usr/local.\" To install it into a different\ndirectory (e.g., one that doesn't require super-user privilege), pass the PREFIX\nvariable to the `make install` command.  For example, to install it into a\n\"jake\" directory in your home directory, you could use this:\n\n    make && make install PREFIX=~/jake\n\nIf do you install Jake somewhere special, you'll need to add the \"bin\" directory\nin the install target to your PATH to get access to the `jake` executable.\n\n### Windows, installing from source\n\nFor Windows users installing from source, there are some additional steps.\n\n*Assumed: current directory is the same directory where node.exe is present.*\n\nGet Jake:\n\n    git clone git://github.com/mde/jake.git node_modules/jake\n\nCopy jake.bat and jake to the same directory as node.exe\n\n    copy node_modules/jake/jake.bat jake.bat\n    copy node_modules/jake/jake jake\n\nAdd the directory of node.exe to the environment PATH variable.\n\n### Basic usage\n\n    jake [options ...] [env variables ...] target\n\n### Description\n\n    Jake is a simple JavaScript build program with capabilities similar to the\n    regular make or rake command.\n\n    Jake has the following features:\n        * Jakefiles are in standard JavaScript syntax\n        * Tasks with prerequisites\n        * Namespaces for tasks\n        * Async task execution\n\n### Options\n\n    -V/v\n    --version                   Display the Jake version.\n\n    -h\n    --help                      Display help message.\n\n    -f *FILE*\n    --jakefile *FILE*           Use FILE as the Jakefile.\n\n    -C *DIRECTORY*\n    --directory *DIRECTORY*     Change to DIRECTORY before running tasks.\n\n    -q\n    --quiet                     Do not log messages to standard output.\n\n    -J *JAKELIBDIR*\n    --jakelibdir *JAKELIBDIR*   Auto-import any .jake files in JAKELIBDIR.\n                                (default is 'jakelib')\n\n    -B\n    --always-make               Unconditionally make all targets.\n\n    -t\n    --trace                     Enable full backtrace.\n\n    -T/ls\n    --tasks                     Display the tasks (matching optional PATTERN)\n                                with descriptions, then exit.\n\n### Jakefile syntax\n\nA Jakefile is just executable JavaScript. You can include whatever JavaScript\nyou want in it.\n\n## API Docs\n\nAPI docs [can be found here](http://mde.github.com/jake/doc/).\n\n## Tasks\n\nUse `task` to define tasks. It has one required argument, the task-name, and\nthree optional arguments:\n\n```javascript\ntask(name, [prerequisites], [action], [opts]);\n```\n\nThe `name` argument is a String with the name of the task, and `prerequisites`\nis an optional Array arg of the list of prerequisite tasks to perform first.\n\nThe `action` is a Function defininng the action to take for the task. (Note that\nObject-literal syntax for name/prerequisites in a single argument a la Rake is\nalso supported, but JavaScript's lack of support for dynamic keys in Object\nliterals makes it not very useful.) The action is invoked with the Task object\nitself as the execution context (i.e, \"this\" inside the action references the\nTask object).\n\nThe `opts` argument is the normal JavaScript-style 'options' object. When a\ntask's operations are asynchronous, the `async` property should be set to\n`true`, and the task must call `complete()` to signal to Jake that the task is\ndone, and execution can proceed. By default the `async` property is `false`.\n\nTasks created with `task` are always executed when asked for (or are a\nprerequisite). Tasks created with `file` are only executed if no file with the\ngiven name exists or if any of its file-prerequisites are more recent than the\nfile named by the task. Also, if any prerequisite is a regular task, the file\ntask will always be executed.\n\nUse `desc` to add a string description of the task.\n\nHere's an example:\n\n```javascript\ndesc('This is the default task.');\ntask('default', function (params) {\n  console.log('This is the default task.');\n});\n\ndesc('This task has prerequisites.');\ntask('hasPrereqs', ['foo', 'bar', 'baz'], function (params) {\n  console.log('Ran some prereqs first.');\n});\n```\n\nAnd here's an example of an asynchronous task:\n\n```javascript\ndesc('This is an asynchronous task.');\ntask('asyncTask', {async: true}, function () {\n  setTimeout(complete, 1000);\n});\n```\n\nA Task is also an EventEmitter which emits the 'start' event when it begins to\nrun, and the 'complete' event when it is finished. This allows asynchronous\ntasks to be run from within other asked via either `invoke` or `execute`, and\nensure they will complete before the rest of the containing task executes. See\nthe section \"Running tasks from within other tasks,\" below.\n\n### File-tasks\n\nCreate a file-task by calling `file`.\n\nFile-tasks create a file from one or more other files. With a file-task, Jake\nchecks both that the file exists, and also that it is not older than the files\nspecified by any prerequisite tasks. File-tasks are particularly useful for\ncompiling something from a tree of source files.\n\n```javascript\ndesc('This builds a minified JS file for production.');\nfile('foo-minified.js', ['bar', 'foo-bar.js', 'foo-baz.js'], function () {\n  // Code to concat and minify goes here\n});\n```\n\n### Directory-tasks\n\nCreate a directory-task by calling `directory`.\n\nDirectory-tasks create a directory for use with for file-tasks. Jake checks for\nthe existence of the directory, and only creates it if needed.\n\n```javascript\ndesc('This creates the bar directory for use with the foo-minified.js file-task.');\ndirectory('bar');\n```\n\nThis task will create the directory when used as a prerequisite for a file-task,\nor when run from the command-line.\n\n### Namespaces\n\nUse `namespace` to create a namespace of tasks to perform. Call it with two arguments:\n\n```javascript\nnamespace(name, namespaceTasks);\n```\n\nWhere is `name` is the name of the namespace, and `namespaceTasks` is a function\nwith calls inside it to `task` or `desc` definining all the tasks for that\nnamespace.\n\nHere's an example:\n\n```javascript\ndesc('This is the default task.');\ntask('default', function () {\n  console.log('This is the default task.');\n});\n\nnamespace('foo', function () {\n  desc('This the foo:bar task');\n  task('bar', function () {\n    console.log('doing foo:bar task');\n  });\n\n  desc('This the foo:baz task');\n  task('baz', ['default', 'foo:bar'], function () {\n    console.log('doing foo:baz task');\n  });\n\n});\n```\n\nIn this example, the foo:baz task depends on the the default and foo:bar tasks.\n\n### Rules\n\nWhen you add a filename as a prerequisite for a task, but there is not a a\nfile-task defined for it, Jake can create file-tasks on the fly from Rules.\n\nHere's an example:\n\n```javascript\nrule('.o', '.c', {async: true}, function () {\n  var cmd = 'cc ' + this.source + ' -c -o ' + this.name;\n  jake.exec(cmd, function () {\n    complete();\n  });\n});\n```\n\nThis rule will take effect for any task-name that ends in '.o', but will require\nthe existence of a prerequisite source file with the same name ending in '.c'.\n\nFor example, with this rule, if you reference a task 'foobarbaz.o' as a\nprerequisite somewhere in one of your Jake tasks, rather than complaining about\nthis file not existing, or the lack of a task with that name, Jake will\nautomatically create a FileTask for 'foobarbaz.o' with the action specified in\nthe rule you've defined. (The usual action would be to create 'foobarbaz.o' from\n'foobarbaz.c'). If 'foobarbaz.c' does not exist, it will recursively attempt\nsynthesize a viable rule for it as well.\n\n#### Regex patterns\n\nYou can use regular expresions to match file extensions as well:\n\n```javascript\nrule(/\\.o$/, '.c', {async: true}, function () {\n  var cmd = 'cc ' + this.source + ' -c -o ' + this.name;\n  jake.exec(cmd, function () {\n    complete();\n  });\n});\n```\n\n#### Source files from functions\n\nYou can also use a function to calculate the name of the desired source-file to\nuse, instead of assuming simple suffix-substitution:\n\n```javascript\n// Match .less.css or .scss.css and run appropriate preprocessor\nvar getSourceFilename = function (name) {\n  // Strip off the extension for the filename\n  return name.replace(/\\.css$/, '');\n};\nrule(/\\.\\w{2,4}\\.css$/, getSourceFilename, {async: true}, function () {\n  // Get appropriate preprocessor for this.source, e.g., foo.less\n  // Generate a file with filename of this.name, e.g., foo.less.css\n});\n```\n\n### Passing parameters to jake\n\nParameters can be passed to Jake two ways: plain arguments, and environment\nvariables.\n\nTo pass positional arguments to the Jake tasks, enclose them in square braces,\nseparated by commas, after the name of the task on the command-line. For\nexample, with the following Jakefile:\n\n```javascript\ndesc('This is an awesome task.');\ntask('awesome', function (a, b, c) {\n  console.log(a, b, c);\n});\n```\n\nYou could run `jake` like this:\n\n    jake awesome[foo,bar,baz]\n\nAnd you'd get the following output:\n\n    foo bar baz\n\nNote that you *cannot* uses spaces between the commas separating the parameters.\n\nAny parameters passed after the Jake task that contain an equals sign (=) will\nbe added to process.env.\n\nWith the following Jakefile:\n\n```javascript\ndesc('This is an awesome task.');\ntask('awesome', function (a, b, c) {\n  console.log(a, b, c);\n  console.log(process.env.qux, process.env.frang);\n});\n```\n\nYou could run `jake` like this:\n\n    jake awesome[foo,bar,baz] qux=zoobie frang=asdf\n\nAnd you'd get the following output:\n\n    foo bar baz\n    zoobie asdf\nRunning `jake` with no arguments runs the default task.\n\n__Note for zsh users__ : you will need to escape the brackets or wrap in single\nquotes like this to pass parameters :\n\n    jake 'awesome[foo,bar,baz]'\n\nAn other solution is to desactivate permannently file-globbing for the `jake`\ncommand. You can do this by adding this line to your `.zshrc` file :\n\n    alias jake=\"noglob jake\"\n\n### Cleanup after all tasks run, jake 'complete' event\n\nThe base 'jake' object is an EventEmitter, and fires a 'start' event before\nrunning, an 'error' event after an uncaught exception, and a 'complete' event after running all tasks.\n\nThis is sometimes useful when a task starts a process which keeps the Node\nevent-loop running (e.g., a database connection). If you know you want to stop\nthe running Node process after all tasks have finished, you can set a listener\nfor the 'complete' event, like so:\n\n```javascript\njake.addListener('complete', function () {\n  process.exit();\n});\n```\n\n### Running tasks from within other tasks\n\nJake supports the ability to run a task from within another task via the\n`invoke` and `execute` methods.\n\nThe `invoke` method will run the desired task, along with its prerequisites:\n\n```javascript\ndesc('Calls the foo:bar task and its prerequisites.');\ntask('invokeFooBar', function () {\n  // Calls foo:bar and its prereqs\n  jake.Task['foo:bar'].invoke();\n});\n```\n\nThe `invoke` method will only run the task once, even if you call it repeatedly.\n\n```javascript\ndesc('Calls the foo:bar task and its prerequisites.');\ntask('invokeFooBar', function () {\n  // Calls foo:bar and its prereqs\n  jake.Task['foo:bar'].invoke();\n  // Does nothing\n  jake.Task['foo:bar'].invoke();\n});\n```\n\nThe `execute` method will run the desired task without its prerequisites:\n\n```javascript\ndesc('Calls the foo:bar task without its prerequisites.');\ntask('executeFooBar', function () {\n  // Calls foo:bar without its prereqs\n  jake.Task['foo:baz'].execute();\n});\n```\n\nCalling `execute` repeatedly will run the desired task repeatedly.\n\n```javascript\ndesc('Calls the foo:bar task without its prerequisites.');\ntask('executeFooBar', function () {\n  // Calls foo:bar without its prereqs\n  jake.Task['foo:baz'].execute();\n  // Can keep running this over and over\n  jake.Task['foo:baz'].execute();\n  jake.Task['foo:baz'].execute();\n});\n```\n\nIf you want to run the task and its prerequisites more than once, you can use\n`invoke` with the `reenable` method.\n\n```javascript\ndesc('Calls the foo:bar task and its prerequisites.');\ntask('invokeFooBar', function () {\n  // Calls foo:bar and its prereqs\n  jake.Task['foo:bar'].invoke();\n  // Does nothing\n  jake.Task['foo:bar'].invoke();\n  // Only re-runs foo:bar, but not its prerequisites\n  jake.Task['foo:bar'].reenable();\n  jake.Task['foo:bar'].invoke();\n});\n```\n\nThe `reenable` method takes a single Boolean arg, a 'deep' flag, which reenables\nthe task's prerequisites if set to true.\n\n```javascript\ndesc('Calls the foo:bar task and its prerequisites.');\ntask('invokeFooBar', function () {\n  // Calls foo:bar and its prereqs\n  jake.Task['foo:bar'].invoke();\n  // Does nothing\n  jake.Task['foo:bar'].invoke();\n  // Re-runs foo:bar and all of its prerequisites\n  jake.Task['foo:bar'].reenable(true);\n  jake.Task['foo:bar'].invoke();\n});\n```\n\nIt's easy to pass params on to a sub-task run via `invoke` or `execute`:\n\n```javascript\ndesc('Passes params on to other tasks.');\ntask('passParams', function () {\n  var t = jake.Task['foo:bar'];\n  // Calls foo:bar, passing along current args\n  t.invoke.apply(t, arguments);\n});\n```\n\n### Getting values out of tasks\n\nPassing a value to the `complete` function for async tasks (or simply returning\na value from sync tasks) will set a 'value' property on the completed task. This\nsame value will also be passed as the task emits its 'complete' event.\n\nAfter a task is completed, this value will be also available in the '.value'\nproperty on the task. Calling `reenable` on the task will clear this value.\n\n\n```javascript\ntask('environment', {async: true}, function () {\n  // Do some sort of I/O to figure out the environment value\n  doSomeAsync(function (err, val) {\n    if (err) { throw err }\n    complete(val);\n  });\n});\n\ntask(\"someTaskWithEnvViaPrereq\", [\"envrionment\"], function () {\n  api = jake.Task[\"envrionment\"].value;\n  console.log(api);\n});\n\ntask(\"someTaskWithEnvViaInvoke\", {async: true}, function () {\n  var env = jake.Task[\"envrionment\"];\n  env.addListener('complete', function (api) {\n    console.log(api);\n    complete();\n  });\n  env.invoke();\n});\n```\n\n### Managing asynchrony without prereqs (e.g., when using `invoke`)\n\nYou can mix sync and async without problems when using normal prereqs, because\nthe Jake execution loop takes care of the difference for you. But when you call\n`invoke` or `execute`, you have to manage the asynchrony yourself.\n\nHere's a correct working example:\n\n```javascript\ntask('async1', ['async2'], {async: true}, function () {\n    console.log('-- async1 start ----------------');\n    setTimeout(function () {\n        console.log('-- async1 done ----------------');\n        complete();\n    }, 1000);\n});\n\ntask('async2', {async: true}, function () {\n    console.log('-- async2 start ----------------');\n    setTimeout(function () {\n        console.log('-- async2 done ----------------');\n        complete();\n    }, 500);\n});\n\ntask('init', ['async1', 'async2'], {async: true}, function () {\n    console.log('-- init start ----------------');\n    setTimeout(function () {\n        console.log('-- init done ----------------');\n        complete();\n    }, 100);\n});\n\ntask('default', {async: true}, function () {\n  console.log('-- default start ----------------');\n  var init = jake.Task.init;\n  init.addListener('complete', function () {\n    console.log('-- default done ----------------');\n    complete();\n  });\n  init.invoke();\n});\n```\n\nYou have to declare the \"default\" task as asynchronous as well, and call\n`complete` on it when \"init\" finishes. Here's the output:\n\n    -- default start ----------------\n    -- async2 start ----------------\n    -- async2 done ----------------\n    -- async1 start ----------------\n    -- async1 done ----------------\n    -- init start ----------------\n    -- init done ----------------\n    -- default done ----------------\n\nYou get what you expect -- \"default\" starts, the rest runs, and finally\n\"default\" finishes.\n\n### Evented tasks\n\nTasks are EventEmitters. They can fire 'complete' and 'error' events.\n\nIf a task called via `invoke` is asynchronous, you can set a listener on the\n'complete' event to run any code that depends on it.\n\n```javascript\ndesc('Calls the async foo:baz task and its prerequisites.');\ntask('invokeFooBaz', {async: true}, function () {\n  var t = jake.Task['foo:baz'];\n  t.addListener('complete', function () {\n    console.log('Finished executing foo:baz');\n    // Maybe run some other code\n    // ...\n    // Complete the containing task\n    complete();\n  });\n  // Kick off foo:baz\n  t.invoke();\n});\n```\n\nIf you want to handle the errors in a task in some specific way, you can set a\nlistener for the 'error' event, like so:\n\n```javascript\nnamespace('vronk', function () {\n  task('groo', function () {\n    var t = jake.Task['vronk:zong'];\n    t.addListener('error', function (e) {\n      console.log(e.message);\n    });\n    t.invoke();\n  });\n\n  task('zong', function () {\n    throw new Error('OMFGZONG');\n  });\n});\n```\n\nIf no specific listener is set for the \"error\" event, errors are handled by\nJake's generic error-handling.\n\n### Aborting a task\n\nYou can abort a task by calling the `fail` function, and Jake will abort the\ncurrently running task. You can pass a customized error message to `fail`:\n\n```javascript\ndesc('This task fails.');\ntask('failTask', function () {\n  fail('Yikes. Something back happened.');\n});\n```\n\nYou can also pass an optional exit status-code to the fail command, like so:\n\n```javascript\ndesc('This task fails with an exit-status of 42.');\ntask('failTaskQuestionCustomStatus', function () {\n  fail('What is the answer?', 42);\n});\n```\n\nThe process will exit with a status of 42.\n\nUncaught errors will also abort the currently running task.\n\n### Showing the list of tasks\n\nPassing `jake` the -T or --tasks flag will display the full list of tasks\navailable in a Jakefile, along with their descriptions:\n\n    $ jake -T\n    jake default       # This is the default task.\n    jake asdf          # This is the asdf task.\n    jake concat.txt    # File task, concating two files together\n    jake failure       # Failing task.\n    jake lookup        # Jake task lookup by name.\n    jake foo:bar       # This the foo:bar task\n    jake foo:fonebone  # This the foo:fonebone task\n\nSetting a value for -T/--tasks will filter the list by that value:\n\n    $ jake -T foo\n    jake foo:bar       # This the foo:bar task\n    jake foo:fonebone  # This the foo:fonebone task\n\nThe list displayed will be all tasks whose namespace/name contain the filter-string.\n\n## Breaking things up into multiple files\n\nJake will automatically look for files with a .jake extension in a 'jakelib'\ndirectory in your project, and load them (via `require`) after loading your\nJakefile. (The directory name can be overridden using the -J/--jakelibdir\ncommand-line option.)\n\nThis allows you to break your tasks up over multiple files -- a good way to do\nit is one namespace per file: e.g., a `zardoz` namespace full of tasks in\n'jakelib/zardox.jake'.\n\nNote that these .jake files each run in their own module-context, so they don't\nhave access to each others' data. However, the Jake API methods, and the\ntask-hierarchy are globally available, so you can use tasks in any file as\nprerequisites for tasks in any other, just as if everything were in a single\nfile.\n\nEnvironment-variables set on the command-line are likewise also naturally\navailable to code in all files via process.env.\n\n## File-utils\n\nSince shelling out in Node is an asynchronous operation, Jake comes with a few\nuseful file-utilities with a synchronous API, that make scripting easier.\n\nThe `jake.mkdirP` utility recursively creates a set of nested directories. It\nwill not throw an error if any of the directories already exists. Here's an example:\n\n```javascript\njake.mkdirP('app/views/layouts');\n```\n\nThe `jake.cpR` utility does a recursive copy of a file or directory. It takes\ntwo arguments, the file/directory to copy, and the destination. Note that this\ncommand can only copy files and directories; it does not perform globbing (so\narguments like '*.txt' are not possible).\n\n```javascript\njake.cpR(path.join(sourceDir, '/templates'), currentDir);\n```\n\nThis would copy 'templates' (and all its contents) into `currentDir`.\n\nThe `jake.readdirR` utility gives you a recursive directory listing, giving you\noutput somewhat similar to the Unix `find` command. It only works with a\ndirectory name, and does not perform filtering or globbing.\n\n```javascript\njake.readdirR('pkg');\n```\n\nThis would return an array of filepaths for all files in the 'pkg' directory,\nand all its subdirectories.\n\nThe `jake.rmRf` utility recursively removes a directory and all its contents.\n\n```javascript\njake.rmRf('pkg');\n```\n\nThis would remove the 'pkg' directory, and all its contents.\n\n## Running shell-commands: `jake.exec` and `jake.createExec`\n\nJake also provides a more general utility function for running a sequence of\nshell-commands.\n\n### `jake.exec`\n\nThe `jake.exec` command takes an array of shell-command strings, and an optional\ncallback to run after completing them. Here's an example from Jake's Jakefile,\nthat runs the tests:\n\n```javascript\ndesc('Runs the Jake tests.');\ntask('test', {async: true}, function () {\n  var cmds = [\n    'node ./tests/parseargs.js'\n  , 'node ./tests/task_base.js'\n  , 'node ./tests/file_task.js'\n  ];\n  jake.exec(cmds, {printStdout: true}, function () {\n    console.log('All tests passed.');\n    complete();\n  });\n\ndesc('Runs some apps in interactive mode.');\ntask('interactiveTask', {async: true}, function () {\n  var cmds = [\n    'node' // Node conosle\n  , 'vim' // Open Vim\n  ];\n  jake.exec(cmds, {interactive: true}, function () {\n    complete();\n  });\n});\n```\n\nIt also takes an optional options-object, with the following options:\n\n * `interactive` (tasks are interactive, trumps printStdout and\n    printStderr below, default false)\n\n * `printStdout` (print to stdout, default false)\n\n * `printStderr` (print to stderr, default false)\n\n * `breakOnError` (stop execution on error, default true)\n\nThis command doesn't pipe input between commands -- it's for simple execution.\n\n### `jake.createExec` and the evented Exec object\n\nJake also provides an evented interface for running shell commands. Calling\n`jake.createExec` returns an instance of `jake.Exec`, which is an `EventEmitter`\nthat fires events as it executes commands.\n\nIt emits the following events:\n\n* 'cmdStart': When a new command begins to run. Passes one arg, the command\nbeing run.\n\n* 'cmdEnd': When a command finishes. Passes one arg, the command\nbeing run.\n\n* 'stdout': When the stdout for the child-process recieves data. This streams\nthe stdout data. Passes one arg, the chunk of data.\n\n* 'stderr': When the stderr for the child-process recieves data. This streams\nthe stderr data. Passes one arg, the chunk of data.\n\n* 'error': When a shell-command exits with a non-zero status-code. Passes two\nargs -- the error message, and the status code. If you do not set an error\nhandler, and a command exits with an error-code, Jake will throw the unhandled\nerror. If `breakOnError` is set to true, the Exec object will emit and 'error'\nevent after the first error, and stop any further execution.\n\nTo begin running the commands, you have to call the `run` method on it. It also\nhas an `append` method for adding new commands to the list of commands to run.\n\nHere's an example:\n\n```javascript\nvar ex = jake.createExec(['do_thing.sh']);\nex.addListener('error', function (msg, code) {\n  if (code == 127) {\n    console.log(\"Couldn't find do_thing script, trying do_other_thing\");\n    ex.append('do_other_thing.sh');\n  }\n  else {\n    fail('Fatal error: ' + msg, code);\n  }\n});\nex.run();\n```\n\nUsing the evented Exec object gives you a lot more flexibility in running shell\ncommmands. But if you need something more sophisticated, Procstreams\n(<https://github.com/polotek/procstreams>) might be a good option.\n\n## Logging and output\n\nUsing the -q/--quiet flag at the command-line will stop Jake from sending its\nnormal output to standard output. Note that this only applies to built-in output\nfrom Jake; anything you output normally from your tasks will still be displayed.\n\nIf you want to take advantage of the -q/--quiet flag in your own programs, you\ncan use `jake.logger.log` and `jake.logger.error` for displaying output. These\ntwo commands will respect the flag, and suppress output correctly when the\nquiet-flag is on.\n\nYou can check the current value of this flag in your own tasks by using\n`jake.program.opts.quiet`. If you want the output of a `jake.exec` shell-command\nto respect the quiet-flag, set your `printStdout` and `printStderr` options to\nfalse if the quiet-option is on:\n\n```javascript\ntask('echo', {async: true}, function () {\n  jake.exec(['echo \"hello\"'], function () {\n    jake.logger.log('Done.');\n    complete();\n  }, {printStdout: !jake.program.opts.quiet});\n});\n```\n\n### FileList\n\nJake's FileList takes a list of glob-patterns and file-names, and lazy-creates a\nlist of files to include. Instead of immediately searching the filesystem to\nfind the files, a FileList holds the pattern until it is actually used.\n\nWhen any of the normal JavaScript Array methods (or the `toArray` method) are\ncalled on the FileList, the pending patterns are resolved into an actual list of\nfile-names. FileList uses the [minimatch](https://github.com/isaacs/minimatch) module.\n\nTo build the list of files, use FileList's `include` and `exclude` methods:\n\n```javascript\nvar list = new jake.FileList();\nlist.include('foo/*.txt');\nlist.include(['bar/*.txt', 'README.md']);\nlist.include('Makefile', 'package.json');\nlist.exclude('foo/zoobie.txt');\nlist.exclude(/foo\\/src.*.txt/);\nconsole.log(list.toArray());\n```\n\nThe `include` method can be called either with an array of items, or multiple\nsingle parameters. Items can be either glob-patterns, or individual file-names.\n\nThe `exclude` method will prevent files from being included in the list. These\nfiles must resolve to actual files on the filesystem. It can be called either\nwith an array of items, or mutliple single parameters. Items can be\nglob-patterns, individual file-names, string-representations of\nregular-expressions, or regular-expression literals.\n\n## PackageTask\n\nWhen you create a PackageTask, it programmically creates a set of tasks for\npackaging up your project for distribution. Here's an example:\n\n```javascript\npackageTask('fonebone', 'v0.1.2112', function () {\n  var fileList = [\n    'Jakefile'\n  , 'README.md'\n  , 'package.json'\n  , 'lib/*'\n  , 'bin/*'\n  , 'tests/*'\n  ];\n  this.packageFiles.include(fileList);\n  this.needTarGz = true;\n  this.needTarBz2 = true;\n});\n```\n\nThis will automatically create a 'package' task that will assemble the specified\nfiles in 'pkg/fonebone-v0.1.2112,' and compress them according to the specified\noptions. After running `jake package`, you'll have the following in pkg/:\n\n    fonebone-v0.1.2112\n    fonebone-v0.1.2112.tar.bz2\n    fonebone-v0.1.2112.tar.gz\n\nPackageTask also creates a 'clobber' task that removes the pkg/\ndirectory.\n\nThe [PackageTask API\ndocs](http://mde.github.com/jake/doc/symbols/jake.PackageTask.html) include a\nlot more information, including different archiving options.\n\n## TestTask\n\nWhen you create a TestTask, it programmically creates a simple task for running\ntests for your project. The first argument of the constructor is the\nproject-name (used in the description of the task), the second (optional)\nargument is a list of prerequisite tasks to run before the tests, and the final\nargument is a function that defines the task. It allows you to specifify what\nfiles to run as tests, and what to name the task that gets created (defaults to\n\"test\" if unset).\n\n```javascript\ntestTask('fonebone', ['asdf', 'qwer'], function () {\n  var fileList = [\n    'tests/*'\n  , 'lib/adapters/**/test.js'\n  ];\n  this.testFiles.include(fileList);\n  this.testFiles.exclude('tests/helper.js');\n  this.testName = 'testMainAndAdapters';\n});\n```\n\nTests in the specified file should be in the very simple format of\ntest-functions hung off the export. These tests are converted into Jake tasks\nwhich Jake then runs normally.\n\nIf a test needs to run asynchronously, simply define the test-function with a\nsingle argument, a callback. Jake will define this as an asynchronous task, and\nwill wait until the callback is called in the test function to run the next test.\n\nIf you name your test 'before', it will run before any of the other tests you\nexport. You can use it for test-setup. If you name a test 'after', it will run\nafter all the other tests have finished. You can use it for teardown. The\n'before' and 'after' will only run once per test module -- *not* before and\nafter each test.\n\nHere's an example test-file:\n\n```javascript\nvar assert = require('assert')\n  , tests;\n\ntests = {\n  'before': function () {\n    // Do some setup here\n  }\n, 'after': function () {\n    // Do some teardown here\n  }\n, 'sync test': function () {\n    // Assert something\n    assert.ok(true);\n  }\n, 'async test': function (next) {\n    // Assert something else\n    assert.ok(true);\n    // Won't go next until this is called\n    next();\n  }\n, 'another sync test': function () {\n    // Assert something else\n    assert.ok(true);\n  }\n};\n\nmodule.exports = tests;\n```\n\nJake's tests are also a good example of use of a TestTask.\n\n## WatchTask\n\nWhen you create a WatchTask, it will watch a directory of files for changes, and\nrun a task or set of tasks anytime there's a change.\n\n```javascript\n// Assumes there's an 'assets' task\nwatchTask(['assets'], function () {\n  this.watchFiles.include([\n    './**/*.ejs'\n  ]);\n});\n```\nRun `jake watch` to start up the WatchTask.\n\nBy default, it will watch the current directory for these files:\n\n```javascript\n[ './**/*.js'\n, './**/*.coffee'\n, './**/*.css'\n, './**/*.less'\n, './**/*.scss'\n]\n```\n\nIt will exclude these files:\n\n```javascript\n[ 'node_modules/**'\n, '.git/**'\n]\n```\n\nThe list of watched files is in a FileList, with the normal `include`/`exclude`\nAPI.\n\n## NpmPublishTask\n\nThe NpmPublishTask builds on top of PackageTask to allow you to do a version\ntump of your project, package it, and publish it to NPM. Define the task with\nyour project's name, and call `include`/`exclude` on the `packageFiles` FileList\nto create the list of files you want packaged and published to NPM.\n\nHere's an example from Jake's Jakefile:\n\n```javascript\nnpmPublishTask('jake', function () {\n  this.packageFiles.include([\n    'Makefile'\n  , 'Jakefile'\n  , 'README.md'\n  , 'package.json'\n  , 'lib/**'\n  , 'bin/**'\n  , 'test/**'\n    ]);\n  this.packageFiles.exclude([\n    'test/tmp'\n  ]);\n});\n```\n\nThe NpmPublishTask will automatically create a `publish` task which performs the\nfollowing steps:\n\n1. Bump the version number in your package.json\n2. Commit change in git, push it to GitHub\n3. Create a git tag for the version\n4. Push the tag to GitHub\n5. Package the new version of your project\n6. Publish it to NPM\n7. Clean up the package\n\nIf you want to publish to a private NPM repository, you can specify a custom publishing command:\n\n```javascript\nnpmPublishTask('jake', function () {\n  this.packageFiles.include([\n  , 'index.js'\n  , 'package.json'\n    ]);\n\n  // Publishes using the gemfury cli\n  // `%filename` will be replaced with the package filename\n  this.publishCmd = 'fury push %filename';\n});\n```\n\n## CoffeeScript Jakefiles\n\nJake can also handle Jakefiles in CoffeeScript. Be sure to make it\nJakefile.coffee so Jake knows it's in CoffeeScript.\n\nHere's an example:\n\n```coffeescript\nutil = require('util')\n\ndesc 'This is the default task.'\ntask 'default', (params) ->\n  console.log 'Ths is the default task.'\n  console.log(util.inspect(arguments))\n  jake.Task['new'].invoke []\n\ntask 'new', ->\n  console.log 'ello from new'\n  jake.Task['foo:next'].invoke ['param']\n\nnamespace 'foo', ->\n  task 'next', (param) ->\n    console.log 'ello from next with param: ' + param\n```\n\n## Related projects\n\nJames Coglan's \"Jake\": <http://github.com/jcoglan/jake>\n\nConfusingly, this is a Ruby tool for building JavaScript packages from source code.\n\n280 North's Jake: <http://github.com/280north/jake>\n\nThis is also a JavaScript port of Rake, which runs on the Narwhal platform.\n\n### License\n\nLicensed under the Apache License, Version 2.0\n(<http://www.apache.org/licenses/LICENSE-2.0>)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mde/jake/issues"
  },
  "homepage": "https://github.com/mde/jake",
  "_id": "jake@0.7.7",
  "_from": "jake@>= 0.7.0"
}
